geoJsonLayer = L.geoJSON(data, {
                style: (f) => ({
                    fillColor: f.properties.color  "#8b0000",
                    color: f.properties.color  "#8b0000",
                    weight: 2,
                    fillOpacity: 0.4
                }),
                pointToLayer: (f, latlng) => L.marker(latlng, { icon: dotIcon }),
                onEachFeature: (f, layer) => {
                    if (f.properties && f.properties.name) {
                        layer.on('click', () => {
                            const activeTooltip = layer.getTooltip();
                            if (activeTooltip) layer.unbindTooltip();
                            else layer.bindTooltip(f.properties.name, { permanent: true }).openTooltip();
                        });
                    }
                }
            }).addTo(map);

            // Если есть полигоны, камера летит к ним
            const bounds = geoJsonLayer.getBounds();
            if (bounds.isValid()) map.fitBounds(bounds);

        } catch (err) {
            console.error(err);
        }
    }

    // 3. РИСОВАЛКА (С ПОДДЕРЖКОЙ ТЕЛЕФОНА)
    const canvas = document.getElementById('paint-canvas');
    const ctx = canvas.getContext('2d');
    let drawing = false, paintMode = false;

    function resize() {
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function toggleDraw() {
        paintMode = !paintMode;
        canvas.classList.toggle('active', paintMode);
        const btn = document.getElementById('drawBtn');
        btn.innerText = paintMode ? "Рисование: ВКЛ" : "Рисование: ВЫКЛ";
        btn.classList.toggle('active', paintMode);
        paintMode ? map.dragging.disable() : map.dragging.enable();
    }

    function getCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function start(e) {
        if (!paintMode) return;
        drawing = true;
        const p = getCoords(e);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.strokeStyle = document.getElementById('colorPicker').value;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
    }

    function move(e) {
        if (!drawing || !paintMode) return;
        if (e.cancelable) e.preventDefault();
        const p = getCoords(e);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
    }

    canvas.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', () => drawing = false);

    canvas.addEventListener('touchstart', (e) => { if(paintMode) start(e); }, {passive:false});
    canvas.addEventListener('touchmove', move, {passive:false});
    canvas.addEventListener('touchend', () => drawing = false);

    function clearCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); }

    // Запуск загрузки
    loadJSON();
</script>

</body>
</html>
